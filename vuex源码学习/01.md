# 第一天学习

## vuex的初始用

- vuex通过export default一个object{}，里面包含了许多的对象，其中就包含了`Store`,这是是一个构造函数，用于接收配置的state，mutation之类的参数,使用`createStore`都会重新new一个store对象，所以不能重复new。

```js
// 这里必定暴露一个install的方法，因为vuex本身是一个对象，并不是一个function--构造函数内部有一个install方法，并且还在定义了$store为全局用法。
import { createApp } from 'vue'
import { createStore } from 'vuex'

// 创建一个新的 store 实例，
const store = createStore({
  state () {
    return {
      count: 0
    }
  },
  mutations: {
    increment (state) {
      state.count++
    }
  }
})

const app = createApp({ /* 根组件 */ })

// 将 store 实例作为插件安装
app.use(store)
```

## devtools，vuex面板

- 在install的同时添加到vue开发面板上面，同步实时观察数据的变化，获得其快照。为某个特定的 Vuex 实例打开或关闭 devtools。对于传入 false 的实例来说 Vuex store 不会订阅到 devtools 插件。对于一个页面中有多个 store 的情况非常有用。

```js
const useDevtools = this._devtools !== undefined
  ? this._devtools
  : __DEV__ || __VUE_PROD_DEVTOOLS__

if (useDevtools) {
  addDevtools(app, this)
}
```

## ModuleCollection收集默认模块

- 通过`ModuleCollection`来注册模块，包括内嵌的模块，进行命名区分。分辨各个模块的数据。

- 通过`new Module(rawModule, runtime)`来初始化每个模块的内容，通过判断path的length来辨别是否是根级模块，后续通过判断`rawModule.modules`来识别当前模块是否包含子模块，如果包含子模块，则循环该子模块进行重新`register`.

```js
register (path, rawModule, runtime = true) {
  if (__DEV__) {
    assertRawModule(path, rawModule)
  }

  const newModule = new Module(rawModule, runtime) // 初始化每个模块的数据
  if (path.length === 0) { // 这个是根目录
    this.root = newModule
  } else {
    const parent = this.get(path.slice(0, -1))
    parent.addChild(path[path.length - 1], newModule)
  }

  // register nested(嵌套) modules
  if (rawModule.modules) {
    forEachValue(rawModule.modules, (rawChildModule, key) => {
      this.register(path.concat(key), rawChildModule, runtime)
    })
  }
}
```
